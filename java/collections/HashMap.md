# HashMap

## 数据结构

- 数组（存储哈希桶） + 链表（拉链法解决哈希冲突） + 红黑树（提高查询效率）
- 允许`null`值，只能存储一个`null`键
- 无序存储
- 初始容量 16，负载因子 0.75，扩容阈值为 **原容量 × 2**

## 特点

- **非线程安全**

需手动同步

- **二次哈希**

对 hashCode 进行二次哈希（减少哈希冲突）

- **扩容机制**

利用容量为 2 的幂的特点，通过**哈希值与旧容量的与运算**快速定位新数组中的索引。

避免了重新计算哈希值的开销，同时减少了元素的移动次数。

- 自定义类作为 key 时必须重写 equals() 和 hashCode() 方法

HashMap的底层是数组 + 链表 / 红黑树，其查找 / 存储 key 的核心逻辑是先通过 hashCode 计算哈希值（确定数组下标），再通过 equals 比较确认是否是同一个 key：

若不重写hashCode()：会使用Object类的默认实现（根据对象的内存地址计算哈希值），即使两个对象的成员变量完全相同，也会被认为是不同对象，哈希值不同； 

若只重写hashCode()不重写equals()：可能出现哈希值相同但对象内容不同的情况（哈希碰撞），此时HashMap会认为这是两个不同的 key，无法正确去重和查找； 

若只重写equals()不重写hashCode()：两个内容相同的对象 equals 返回 true，但哈希值不同，会被放到HashMap的不同数组位置，失去哈希表的查找意义，也无法去重。